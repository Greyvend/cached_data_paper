\documentclass[10pt,a4paper]{article}
\author{Мосин Сергей, Зыкин Сергей}
\usepackage{amssymb,amsmath}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{xcolor}
\floatname{algorithm}{Алгоритм}
\newtheorem{theorem}{Теорема}
\newtheorem{mydef}{Определение}
\newtheorem{statement}{Утверждение}
\newtheorem*{consequence}{Следствие}
\newtheorem{note}{Замечание}
\def \eval #1#2{\left.#1\right\vert_{#2}}
\def \<#1> {\langle #1 \rangle}
\def \n #1{\mathit{#1}}
\title{Формирование табличных приложений с использование зарезервированных
представлений данных}
\author{
Мосин С.В., Зыкин С.В. \footnote{Работа выполнена при поддержке гранта РФФИ №
12-07-00066-а}
}
\date{}

\begin{document}
\maketitle

\section{Введение}

Многие современные решения в области анализа больших объемов данных
используют технологии аналитической обработки данных (Online Analytical
Processing), сформировавшиеся еще в начале 90-х годов \cite{codd}. За последнее
время в этой области было получено большое количество фундаментальных
\cite{lecht,lehner,mazon} и практических результатов \cite{vassi, peder,
progressive, giorg}.

Целью данной работы, включая результаты этой статьи, является изучение
проблемы динамического формирования
многомерного представления данных из реляционной базы данных с
помощью зарезервированных представлений на компьютере пользователя, оснащенном
графическим процессором (GPU). При этом не предполагается какое-либо
преобразование исходной схемы базы данных, в том числе к иерархическому виду.

Поставленная проблема связана с областью оптимизации
запросов, поскольку нацелена на сокращение объема передаваемых данных с сервера
базы данных. Зарезервированные данные активно используется в системах управления
базами данных (СУБД). Но в большинстве случаев это касается повторного
использования данных, записанных в кеш, без предварительного анализа
содержимого на предмет возможности частичного или комбинированного
использования. Работа СУБД ограничивается тем, что при выполнении очередного
запроса блоки данных не запрашиваются с внешних устройств, если они есть в
кеше, т. е. анализируются номера блоков, а не их содержимое.

Данная работа основывается на результатах, полученных в
статье \cite{zyk_pol}. Устранено условие, ограничивающее атрибуты промежуточного
представления, а также сделано обобщение теорем на случай нескольких
промежуточных представлений.

\section{Обзор публикаций и сравнение}

В области теоретических исследований ситуация складывается следующим образом.
Огромное число публикаций посвящено проблеме построения оптимального плана
запроса на основе формальных правил, в которых не используются области
определения предикатов в SQL-операторах (логическая оптимизация) либо эти
области учитываются при вычислении статистических оценок для оптимизации
физического доступа к базе данных. Близкими по методам решения являются задачи
выполнения запросов на потоках данных \cite{Olston03, Denny05}, однако
различные, по сравнению с настоящей работой, цели приводят к различным
результатам. Наиболее близка к рассматриваемой проблеме работа \cite{Afrati06}.
В ней рассматриваются конъюнктивные запросы над доменами данных с предикатами
в виде арифметических сравнений и представлены алгоритмы вычисления запросов с
использованием существующих представлений. В настоящей работе рассматривается
специальный вид универсального реляционного запроса над отношениями базы данных,
а не над отдельными доменами. Хотя цели в обеих работах совпадают, результаты
различны по указанной причине. В частности, в настоящей работе нет необходимости
разрабатывать алгоритмы выборки данных из промежуточных представлений, так как
их замещает реляционная алгебра.

Существует ряд работ, в которых рассматривается проблема оптимизации
запросов к хранилищам данных, имеющих концептуальное многомерное представление,
с использованием динамически формируемых представлений. При этом
существуют два основных подхода для резервирования результатов запросов:
статический \cite{baralis, gupta, gupta-mumick} и динамический \cite{scheuermann, shim,
kalnis, chang}. Первый базируется на использовании набора фиксированных запросов,
во втором же предполагается динамический выбор результатов запросов для резервирования на
основе статистики появления а также вычислительной стоимости выполнения
запросов. В качестве источника данных используются хранилища данных, либо
реляционная база данных, преобразованная к иерархическому виду. При этом,
рассматриваются специальные запросы манипулирования многомерными данными. 
В этой статье рассматривается технология раздельного формирования размерностей
представления данных, необходимого для текущего анализа. Поэтому интерес
представляют стандартные SQL запросы к базе данных и промежуточным представлениям. 
Результирующее представление может быть затем обработано специальными запросами
манипулирования многомерными данными.

В работе \cite{Keller96} решается задача анализа содержимого кеша,
при этом промежуточным представлениям
в кеше ставятся в соответствие предикаты. Проблема использования представлений
решается за счет выводимости предикатов. В данной работе проблему использования
промежуточных представлений предлагается решать за счет вычисления областей
определения (доменов) результатов выполнения запросов, находящихся в кеше,
соответствующих промежуточным представлениям. Это дает возможность
определить кортежи, которые можно использовать в зарезервированных представлениях
при формировании нового представления, и на основе вычисления областей определения
сформировать SQL команды, которые позволят загрузить недостающие данные с сервера
базы данных. Для демонстрации предлагаемых решений рассмотрим пример.

{\bf Пример 1.} Допустим, что требуется получить представление данных, как показано в
таблице \ref{def_T_1}. Жирным шрифтом в этой таблице представлены атрибуты размерностей,
курсивом - атрибуты мер, значения атрибутов - обычным шрифтом.

\begin{table}[h!]
\caption{\label{def_T_1} Фрагмент учебного плана.}
\begin{center}
\begin{tabular}{|c|c||c|c|c|c|}
\cline{2-6}
\multicolumn{1}{c|}{} & \multicolumn{1}{|r||}{\bf Семестр} & \multicolumn{2}{|c|}{2} & \multicolumn{2}{|c|}{3}  \\
\cline{2-6}
\multicolumn{1}{c|}{} & {\bf Предмет} & Физика & Химия & Физика & Химия \\
\hline \cline{2-6}
{\bf Факультет} & {\bf Группа} & {\it Часы} & {\it Часы} & {\it Часы} & {\it Часы} \\
\hline
 & Х-321 & & 36 & 18 & 9 \\
\cline{2-6}
Химический & Х-322 & & 48 & 18 & 9 \\
\cline{2-6}
 & Х-331 & & 24 & 18 & 9 \\
\hline
 & Ф-321 & 48 & & 24 & \\
\cline{2-6}
Физический & Ф-322 & 48 & & 24 & \\
\cline{2-6}
 & Ф-331 & 64 & & 24 & \\
\hline
\end{tabular}
\end{center}
\end{table}
Пусть на компьютере пользователя имеются следующие таблицы: $P_1$,
$P_2$, $P_3$, сформированные заранее. Схема таблицы $P_1$=(Номер факультета, Факультет), без ограничений на данные;
схема таблицы $P_2$=(Номер предмета, Предмет), без ограничений на данные;
схема таблицы $P_3$=(Номер факультета, Номер предмета, Семестр, Группа, Часы), со следующим ограничением:
$F_3 =(\mbox{Семестр} \leq 2) \wedge (\mbox{Факультет} = \mbox{Химический})$.
Пусть при формировании схемы представления данных в таблице \ref{def_T_1} пользователь задал следующее
ограничение на нее: $F^{\ast} = (\mbox{Семестр} \leq 3)$.
Сравнение областей истинности формул для ограничений позволит сделать вывод, что $P_1$ и $P_2$ имеют
достаточно данных для формирования таблицы \ref{def_T_1}, а $P_3$ требует дополнения данных.
Вычисление областей истинности формул $F^{\ast}$ и $F_3$ позволит сформировать новую формулу:
$F=((\mbox{Семестр} = 3) \wedge (\mbox{Факультет=Химический}))
\vee ((\mbox{Семестр} \leq 3) \wedge (\mbox{Факультет} \neq \mbox{Химический}))$. Использую схему $P_3$ и
формулу $F$ формируется команда SQL, которая передается на сервер для исполнения. В конечном счете,
по сети передается меньше данных.

\section{Определение и свойства логических ограничений}

Для упрощения вычисления областей истинности будем рассматривать логические формулы в дизъюнктивной
нормальной форме. В общем случае формула $F$ имеет вид 

\begin{equation}
F = K_1 \vee K_2 \vee \dots \vee K_m ,
\label{def_F_1}
\end{equation}
\begin{equation}
K_i = T_1 \& T_2 \dots \& T_n, i = 1, \dots, m ,
\label{def_F_2}
\end{equation}
где $T_j, j = 1, \dots, n$ - предикаты, в которых явным образом
специфицированы расширенные имена атрибутов $R_i.A_j$ (атрибут $A_j$ в отношении
$R_i$):
\begin{itemize}
  \item	операция сравнения $ \n{Expr}_1 \theta \n{Expr}_2$, $\theta$ – операция
  сравнения $(\theta \in \{=, \neq, >, <, \leq, \geq\})$, $\n{Expr}_i$ –
  согласованные по типам допустимые выражения, определенные на множестве
  расширенных имен атрибутов и констант;
  \item операция $\n{Expr}_1 \n{[NOT]} \n{BETWEEN} \n{Expr}_2 \n{AND}
  \n{Expr}_3$ (содержимое в прямоугольных скобках $[*]$ для предиката не
  является обязательным при написании);
  \item операция $\n{Expr} \n{[NOT]} \n{IN} S$, где $S$ – список значений либо
  подзапрос, результатом которого является столбец атрибута $A_j$ в отношении
  $R_i$;
  \item операция $\n{Str}_1 \n{[NOT]} \n{LIKE} \n{Str}_2$, где $\n{Str}_i$ –
  строки;
  \item операция $\n{Expr} \theta \n{ALL/ANY} S$.
\end{itemize}

\begin{note}
Здесь и далее будем полагать, что в формулах отсутствуют тривиальные условия на
атрибуты, например, условия вида $Expr_1 = Expr_1$ и сводящихся к ним.
В общем случае будем полагать, что множество возможных значений атрибута $A_l$
в отношении $R_i$ не включается целиком в область истинности предиката $T_j (\dots , R_i . A_l ,\dots )$. Такие
условия могут быть удалены из формулы, не меняя области истинности (будет
определено далее).
\label{trivial}
\end{note}

\begin{mydef}
Множество атрибутов, входящих в формулу, выражает размерность формулы и
обозначается $\<F> $.

\begin{equation}
\<F> = \{R_1^F.A_1^F, \dots, R_k^F.A_k^F\}
\label{def_F_3}
\end{equation}
\end{mydef}



Перечисленные варианты операций используют не все возможности языка SQL.
Например, предикат $\n{EXISTS}$ не используется, поскольку в нем явно не
специфицированы расширенные имена атрибутов, предикат $\n{NULL}$ используется
в данной работе для другой цели.

При вычислении логического выражения может быть получено значение $\n{UNKNOWN}$,
если на текущем кортеже $t$ атрибут принимает значение $\n{NULL}$, поскольку
результаты вычисления логических выражений в SQL-запросах соответствуют
трехзначной логике. Это приводит к неоднозначной интерпретации результата не только
обычными пользователями, но и опытными программистами. Для решения этой проблемы
предлагается ограничение: каждому атрибуту, входящему в $F^{\ast}$, явно присваивается признак
<<Использование неопределенного значения>> с двумя взаимоисключающими значениями <<Да>> или <<Нет>>.
Семантика этого признака такова, что если ему присвоено значение <<Да>>, то появление значения $\n{NULL}$
для указанного атрибута в текущем кортеже $t$ не служит основанием удаления этого кортежа из
дальнейшего рассмотрения. В противном случае значение признака <<Нет>> гарантирует, что появление
значения $\n{NULL}$ для указанного атрибута в текущем кортеже $t$ приведет к удалению этого кортежа из
дальнейшего рассмотрения.

Запишем формулу (\ref{def_F_1}) для $F$ в следующем виде: $ F ( \dots, T_j , \dots )$, где $T_j$ - предикаты
формулы (\ref{def_F_2}). Тогда после предложенного преобразования она примет следующий вид:
$F( \dots, T'_j , \dots )\wedge_{i,j}(R_i .A_j \neq  \n{NULL})$, где  $\wedge_{i,j}(R_i .A_j \neq  \n{NULL})$ - конъюнкция
по всем атрибутам формулы $F$, для которых не допустимо значение $\n{NULL}$.
Операция $T'_j = (T_j \vee_{i,j}(R_i .A_j = \n{NULL}))$, где  $\vee_{i,j}(R_i .A_j = \n{NULL})$ - дизъюнкция
по всем атрибутам предиката $T_j$, для которых допустимо значение $\n{NULL}$. Внешние скобки для предиката
$T'_j$ определяют приоритет выполнения операций. Несложно убедиться, что в рамках трехзначной логики
преобразованная формула принимает только значения $\n{TRUE}$ и $\n{FALSE}$. Кроме того, несложно убедиться,
что в рамках двузначной логики, когда в кортежах отсутствуют неопределенные значения, исходная формула $F$
будет эквивалентна преобразованной формуле, поэтому семантика представления $P$ практически не искажается.
Для раскрытия термина "практически" рассмотрим наиболее неудобный пример: пусть $F = R_1 .A_2 > 3 \vee R_3 .A_4 < 4$
и на кортеже $t$ атрибут $R_1 .A_2$ принимает допустимое значение $\n{NULL}$, а предикат $R_3 .A_4 < 4$ принимает
значение $\n{FALSE}$. Тогда преобразование формулы $F$ на кортеже $t$ будет иметь значение $\n{TRUE}$,
что не совсем очевидно. Далее будем предполагать, что все формулы $F$ являются преобразованными.

Введем в рассмотрение множество $\mathcal{A} =$ $\{(a_1, \dots, a_n)
\mid a_i \in Dom(A_i), i=1,\dots,n\}$, где $Dom(A_i)$ - множество всех допустимых значений атрибута $A_i$.
Декартово прозведение $Dom(A_1)\times Dom(A_2)\times \dots \times Dom(A_n)$ - $n$-мерное пространство
значений всех атрибутов базы данных. Текущее состояние базы данных соответствует точке в этом пространстве.
Допустимые состояния образуют некоторую область в этом пространстве, соответствующую ограничениям целостности на данные.
В замечании \ref{trivial} речь идет о всем пространстве состояний, а не только допустимых состояниях.

\begin{mydef}
Областью истинности логической формулы $F$, заданной (\ref{def_F_1}),
(\ref{def_F_2}), (\ref{def_F_3}), является множество, определяемое по следующему
правилу: $M (F) = \{a \in \mathcal{A} \mid F(a) = \n {TRUE}\}$.
\end{mydef}

\begin{note}
Размерность формулы $F$ может быть меньше
размерности $\mathcal{A}$, при этом атрибуты, не входящие в формулу, могут
принимать любые значения.
\end{note}

\begin{note}
Сложность компонентов предикатов $\n{Expr}$, $S$ и $\n{Str}$ определяется
возможностями программного обеспечения по вычислению областей истинности
$F$, как это показано в примере 1.
\end{note}

В соответствии с данными определениями легко понять, как будут устроены операции
над областями истинности, соответствующими формулам. $M (F)$ для некоторой формулы
$F$, заданной своей ДНФ, является объединением областей истинности, представленных
отдельными конъюнктами формулы. Область истинности каждого конъюнкта определяется
определяется как пересечение областей истинности предикатов, входящих в него.

Далее введем определения, касающиеся модификации вхождения атрибутов в
логические формулы.

\begin{mydef}
Проекцей логической формулы $F$, заданной (\ref{def_F_1}), (\ref{def_F_2}),
(\ref{def_F_3}), на множество атрибутов $X$ называется логическая
формула $F[X], \<F[X]> $
$= X$, в которой все термы, содержащие
атрибуты $R_i^F.A_i^F \notin X$, заменены на тривиальный терм $\n{TRUE}$.
\label{projection}
\end{mydef}

\begin{statement}[Свойство включения]
$\forall X \subseteq \<F> \quad M(F) \subseteq M(F[X])$
\label{proj_property_of_inclusion}
\end{statement}
\begin{proof}
Если $X = \<F> $, то $F = F[X]$ и $M(F) = M(F[X])$. Пусть $X \subset \<F> $. Рассмотрим
произвольную точку $a \in M(F)$, то есть $F(a)=\n{TRUE}$. Преобразование формулы $F$
к виду $F[X]$ выполняется заменой предикатов $T_j$ значением $\n{TRUE}$, если они содержат
атрибут $A_j \in \<F> $ и $A_j \notin X$. Учитывая соотношения  (\ref{def_F_1}) и (\ref{def_F_2}),
получим $F([X])=\n{TRUE}$. Следовательно, $a \in M(F[X])$, что и требовалось показать.
\end{proof}

Данное свойство логических ограничений, заданных на состояниях базы
данных, в дальнейшем используется при формировании нового представления данных
из существующих сохраненных представлений.

\section{Исследование свойств промежуточных представлений данных}

Сохраненные промежуточные представления данных обозначим $P$=$\{ P_1$, $P_2$, $\dots$, $P_m \}$,
где $P_v = \pi_{X_v}(\sigma_{F_v} (R^v_1 \Join R^v_2 \Join \dots \Join R^v_{s(v)} ))$,
$s(v)$ – количество отношений в базе данных, использованных при формировании представления $P_v$,
$\pi_{X_v}$ - операция проекции по множеству атрибутов $X_v$, $\sigma_{F_v}$ - операция селекции
с логическим ограничением на кортежи $F_v$.
Целевое выражение, которое надо будет получить из представлений $P$, запишем в виде:
$$P^{\ast} = \pi_{X^{\ast}}(\sigma_{F^{\ast}} (R^{\ast}_1 \Join R^{\ast}_2\Join \dots \Join R^{\ast}_l )$$

Рассмотрим проблему формирования представления данных $P^{\ast}$ из существующих промежуточных
представлений $P_v$.

\input{theorem_1}

Предложенные в теореме условия гарантируют, что данные, необходимые для формирования
представления $P^{\ast}$, содержатся в промежуточном представлении $P_v$. Однако в нем
могут быть лишние кортежи, которые дают значение $\n{TRUE}$ при подстановке в формулу
$F^{\ast}$. Дело в том, что эти кортежи будут удалены при выполнении операции естественного
соединения с отношениями, которых не хватает в множестве $R^v_1 \Join R^v_2 \Join \dots \Join R^v_{s(v)} $
для совпадения с множеством $R^{\ast}_1 \Join R^{\ast}_2\Join \dots \Join R^{\ast}_l $.
Используя области области истинности логических выражений у СУБД можно запросить
минимально необходимый набор данных для определения лишних кортежей.

Следующая теорема соответствует частному случаю, однако проблема лишних кортежей не возникает.

\input{theorem_2}

Для формирования результирующего представления возможно использование
не одного, а нескольких промежуточных представлений $P_v$. Для этого
рассмотрим достаточно очевидное свойство операции естественного соединения.

\begin{statement}
Пусть $\Re_1 = R_1 \Join \dots \Join R_k$ - результат естественного
соединения некоторых $k$ отношений. Пусть также $\Re_2 = R_1 \Join \dots
\Join R_k \Join R_{k+1} \Join \dots \Join R_{n}$. 
Тогда $\Re_2 [\langle \Join_{i=1}^{k} R_i \rangle] \subseteq \Re_1$
\label{join_property}
\end{statement}

Это действительно так, поскольку после проведения операции естественного соединения
с дополнительными отношениями исходные кортежи, содержавшиеся в $\Re_1$, могут
лишь ''отсеяться'' операцией естественного соединения. Тогда, взяв вырезку по
исходным атрибутам, получим как максимум то же самое отношение $\Re_1$. Поскольку
операция естественного соединения коммутативна, то порядок присоединения отношений
не имеет значения.

\input{theorem_1_mult}

Как и в предыдущем случае существуют условия, при которых целевое представление
данных можно вычислить точно.

\input{theorem_2_mult}

Выполнение условий рассмотренных теорем не представляет собой  исключительный случай,
поскольку набор размерностей при формировании гиперкубов изменяется редко, что позволит
формировать эти размерности из промежуточных представлений без обращения к СУБД.

\section{Заключение}

Основной результат данной работы состоит в обосновании условий использования
зарезервированных представлений данных для формирования новых гиперкубов.
Эти представления данных могут храниться на компьютере пользователя-аналитика
и существенно сократить время на формирование данных, необходимых для принятия решений.

Традиционная проблема в системах, работающих не под управлением СУБД, заключается
в актуализации данных, полученных из БД. В технологии MOLAP она решается путем периодической
актуализации содержимого гиперкуба службой сопровождения. Аналогичный способ может быть
применен для актуализации представлений $P_v$. Для сокращения времени актуализации возможно
получить доступ к журналу изменений, который сопровождает СУБД, и актуализировать только те
представления, для которых изменились исходные данные в БД. Однако еще раз отметим, что данные,
используемые в размерностях гиперкуба, обычно редко модифицируются в БД.

Предлагаемый подход подразумевает в дальнейшем применение графических процессоров
для выполнения промежуточных операций фильтрации и соединения различных представлений данных.
Исследования в этой области показали, что операции на графическом процессоре выполняются
существенно быстрее, чем на центральном процессоре, для небольших объемов данных. При увеличении
объемов производительность падает. Причина очевидна: пока данные помещаются в быструю память
графического процессора, операции с ними выполняются быстро. При увеличении объемов данных появляется
необходимость их многократного перемещения между различными видами памяти, что снижает
производительность. С одной стороны, производители графических процессоров постоянно наращивают
быструю память, с другой – повторное использование данных наиболее актуально для размерностей
многомерных таблиц, для которых требуется сравнительно небольшой объем памяти, что в совокупности
делает целесообразным применение графических процессоров при решении указанной проблемы.


\input{bibliography}
\end{document}