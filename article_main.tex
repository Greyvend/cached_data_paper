\documentclass[10pt,a4paper]{article}
\author{Мосин Сергей, Зыкин Сергей}
\usepackage{amssymb,amsmath}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{xcolor}
\floatname{algorithm}{Алгоритм}
\newtheorem{theorem}{Теорема}
\newtheorem{mydef}{Определение}
\newtheorem{statement}{Утверждение}
\newtheorem*{consequence}{Следствие}
\newtheorem{note}{Замечание}
\def \eval #1#2{\left.#1\right\vert_{#2}}
\def \<#1> {\langle #1 \rangle}
\def \n #1{\mathit{#1}}
\begin{document}

\section{Введение}
Многие современные решения в области анализа больших объемов данных
используют технологии аналитической обрабоки данных (Online Analytical
Processing), сформировавшиеся еще в начале 90-х годов \cite{codd}. За последнее
время в этой области было получено большое количество фундаментальных
\cite{lecht,lehner,mazon} и практических результатов \cite{vassi, peder,
progressive, giorg}.

Целью данной работы является изучение проблемы динамического формирования
гиперкубического представления базы данных из реляционной базы данных (РБД) с
помощью зарезервированных представлений данных на компьютере, оснащенном
графическим процессором (GPU). Эта проблема связана с областью оптимизации
запросов, поскольку нацелена на сокращение объема передаваемых данных с сервера
БД. Зарезервированные данные активно используется в системах управления базами
данных (СУБД). Но в большинстве случаев это касается повторного использования
данных, предварительно записанных в буферный пул, без предварительного анализа
содержимого на предмет возможности частичного или комбинированного
использования. Работа СУБД ограничивается тем, что при выполнении очередного
запроса блоки данных не запрашиваются с внешних устройств, если они есть в
буферном пуле, т. е. анализируются номера блоков, а не их содержимое.

В области теоретических исследований ситуация складывается следующим образом.
Огромное число публикаций посвящено проблеме построения оптимального плана
запроса на основе формальных правил, в которых не используются области
определения предикатов в SQL-операторах (логическая оптимизация) либо эти
области учитываются при вычислении статистических оценок для оптимизации
физического доступа к БД. Близкими по методам решения являются задачи
выполнения запросов на потоках данных [9, 10], однако различные, по сравнению
с настоящей работой, цели приводят к различным результатам. Наиболее близка к
рассматриваемой проблеме работа [11]. В ней рассматриваются конъюнктивные
запросы над доменами данных с предикатами в виде арифметических сравнений и
представлены алгоритмы вычисления запросов с использованием существующих
представлений. В настоящей работе рассматривается специальный вид универсального
реляционного запроса над отношениями базы данных, а не над отдельными доменами.
Хотя цели в обеих работах совпадают, результаты различны по указанной причине.
В частности, в настоящей работе нет необходимости разрабатывать алгоритмы, так
как их замещает реляционная алгебра.

Существует ряд работ, в которых рассматривается подход к оптимизации запросов
именно в многомерных базах данных и хранилищах данных.
Есть два основных подхода для резервирования результатов запросов: статический
\cite{baralis, gupta, gupta-mumick} и динамический\cite{scheuermann, shim,
kalnis, chang}. Первый базируется на использовании набора фиксированных
запросов, во втором же предполагается динамический выбор результатов запросов
для резервирования на основе статистики появления а также вычислительной
стоимости выполнения запросов. В отличие от подходов, применяемых в реляционных
СУБД, здесь проводится анализ самих запросов. Однако подходы, описанные в
данных статьях, применимы лишь для технологий реляционных многомерных баз данных
(ROLAP) и используют специальные для многомерных баз данных типы запросов, в то
время как в нашем случае используются стандартные SQL запросы. Данная работа
базируется на результатах, полученных в статье \cite{zyk_pol}. Устранено
условие, ограничивающее атрибуты промежуточного представления, а также сделано
обобщение теорем на случай нескольких промежуточных представлений. В заключение
приводятся алгоритмы, позволяющие применять на практике полученные результаты.

\section{Определение и свойства логических ограничений}

Будем рассматривать логические формулы в дизъюнктивной нормальной форме. Тогда
формула $F$ имеет вид 

\begin{equation}
F = K_1 \vee K_2 \vee \dots \vee K_m
\label{def_F_1}
\end{equation}
\begin{equation}
K_i = T_1 \& T_2 \dots \& T_n, i = 1, \dots, m
\label{def_F_2}
\end{equation}

$T_j, j = 1, \dots, n$ - предикаты, в которых явным образом
специфицированы расширенные имена атрибутов $R_i.A_j$ (атрибут $A_j$ в отношении
$R_i$):
\begin{itemize}
  \item	операция сравнения $ \n{Expr}_1 \theta \n{Expr}_2$, $\theta$ – операция
  сравнения $(\theta \in \{=, \neq, >, <, \leq, \geq\})$, $\n{Expr}_i$ –
  согласованные по типам допустимые выражения, определенные на множестве
  расширенных имен атрибутов и констант;
  \item операция $\n{Expr}_1 \n{[NOT]} \n{BETWEEN} \n{Expr}_2 \n{AND}
  \n{Expr}_3$ (содержимое в прямоугольных скобках $[*]$ для предиката не
  является обязательным при написании);
  \item операция $\n{Expr} \n{[NOT]} \n{IN} S$, где $S$ – список значений либо
  подзапрос, результатом которого является столбец атрибута $A_j$ в отношении
  $R_i$;
  \item операция $\n{Str}_1 \n{[NOT]} \n{LIKE} \n{Str}_2$, где $\n{Str}_i$ –
  строки;
  \item операция $\n{Expr} \theta \n{ALL/ANY} S$.
\end{itemize}

\begin{note}
Здесь и далее будем полагать, что в формулах нет тривиальных условий на
атрибуты, то есть условий вида $Expr_1 = Expr_1$ и сводящихся к ним. Такие
условия могут быть удалены из формулы, не меняя области истинности (будет
определено далее).
\label{trivial}
\end{note}

\begin{mydef}
Множество атрибутов, входящих в формулу, выражает размерность формулы и
обозначается $\<F> $.

\begin{equation}
\<F> = \{R_1^F.A_1^F, \dots, R_k^F.A_k^F\}
\label{def_F_3}
\end{equation}
\end{mydef}



Перечисленные варианты операций используют не все возможности языка SQL.
Например, предикат $\n{EXISTS}$ не используется, поскольку в нем явно не
специфицированы расширенные имена атрибутов, предикат $\n{NULL}$ используется
в данной работе для другой цели.

При вычислении логического выражения может быть получено значение $\n{UNKNOWN}$,
если на текущем кортеже $t$ атрибут принимает значение $\n{NULL}$, поскольку
результаты вычисления логических выражений в SQL-запросах соответствуют
трехзначной логике. Для избежания такой ситуации формулы преобразуются
определенным образом, изложенным в статье \cite{zyk_pol}.

В дальнейшем будем использовать множество $\mathcal{A} =$ $\{(a_1, \dots, a_l)
\mid a_i \in Dom(A_i), i=1,\dots,l\}$, $l$-мерное пространство значений всех
атрибутов базы данных.

\begin{mydef}
Областью истинности логической формулы $F$, заданной (\ref{def_F_1}),
(\ref{def_F_2}), (\ref{def_F_3}), является множество, определяемое по следующему
правилу: $M (F) = \{a \in \mathcal{A} \mid F(a) = \n {TRUE}\}$.
\end{mydef}

\begin{note}
Размерность формулы $F$ может быть меньше
размерности $\mathcal{A}$, при этом атрибуты, не входящие в формулу, могут
принимать любые значения.
\end{note}

\begin{note}
Сложность компонентов предикатов $\n{Expr}$, $S$ и $\n{Str}$ определяется
возможностями программного обеспечения по вычислению областей определения
$\n{Dom} (F_v)$, что необходимо для вычисления $TJ(C_s)$ из промежуточных
представлений $P_v$.
\end{note}

В соответствии с данными определениями легко понять, как будут устроены операции
над областями, соответствующими формулам. $\n{Dom} (F)$ для некоторой формулы
$F$, заданной своей ДНФ, является объединением областей, представленных
отдельными конъюнктами формулы. Область $M(F)$ является подобластью области
$\n{Dom} (F)$, то есть $M(F) \subseteq \n{Dom} (F)$. Включение $M(F_1) \subseteq
M(F_2)$ означает, что область истинности каждого конъюнкта $F_1$ является
подобластью некоторого объединения областей истинности конъюнктов $F_2$.

Теперь введем определения, касающиеся модификации вхождения атрибутов в
логические формулы.

\begin{mydef}
Проекцей логической формулы $F$, заданной (\ref{def_F_1}), (\ref{def_F_2}),
(\ref{def_F_3}), на множество атрибутов $X$ называется логическая
формула $F[X], \<F[X]> $
$= X$, в которой все термы, содержащие
атрибуты $R_i^F.A_i^F \notin X$, заменены на тривиальный терм TRUE.
\label{projection}
\end{mydef}

\begin{statement}[Свойство включения]
$\forall X \subseteq \<F> \quad M(F) \subseteq M(F[X])$
\label{proj_property_of_inclusion}
\end{statement}
\begin{proof}
Рассмотрим некоторую точку $a \in M(F)$. 
Так как формула находится в ДНФ, то замена некоторого предиката $T$ на значение
$\n{TRUE}$, очевидно, может либо полностью сделать значение формулы $\n{TRUE}$,
если предикат $T$ единственный в конъюнкте $K_i = T$, либо сократить количество
условий в нём, если $K_i = T \& T'_1 \dots \& T'_n$. В любом из этих случаев
количество условий в формуле $F[X]$ лишь уменьшается, что гарантирует выполнение
$F[X](a) = \n{TRUE}$ и, следовательно, $a \in M(F[X])$
\end{proof}

\begin{statement}
$M(F_1) \subseteq M(F_2) \Rightarrow \<F_2> \subseteq \<F_1> $
\label{attibute_inclusion_property}
\end{statement}
\begin{proof}
Пусть это условие не выполняется. Тогда $U' = \<F_2> \setminus \<F_1> \neq
\emptyset$. Выберем точку $a = (a_1, \dots, a_l) \in M(F_1)$. Для некоторого
атрибута $A_i \in U'$ выберем соответствующую координату $a_i \in Dom(A_i)$. Так
как по замечанию \ref{trivial} в формулах нет тривиальных условий на атрибуты, то $\exists a_i'
\in Dom(A_i) : a' = (a_1, \dots, a_{i - 1}, a_i', a_{i + 1}, \dots, a_l) \notin
M(F_2)$. Однако $a' \in M(F_1)$, так как атрибут $A_i$ отсутствует в формуле
$F_1$. Следовательно, $M(F_1) \nsubseteq M(F_2)$. Полученное противоречие
доказывает утверждение.
\end{proof}

\begin{consequence}
$M(F_1) = M(F_2) \Rightarrow \<F_2> = \<F_1> $
\label{attibute_equality_property}
\end{consequence}
\begin{proof}
Пусть это условие не выполняется. Тогда, в силу предыдущего утверждения,
существует множество $U' = \<F_1> \setminus \<F_2> \neq \emptyset$. Аналогично
предыдущему доказательству, выбираем точку из любого из множеств и меняем
значение координаты, соответствующей атрибуту из множества $U'$ на такое,
которое не принаджежит множеству $M(F_1)$. Полученная точка по-прежнему
принадлежит $M(F_2)$. Мы снова пришли к противоречию. Утверждение доказано.
\end{proof}

\section{Исследование свойств промежуточных представлений данных}

\input{theorem_1}

\input{theorem_2}

Эти результаты можно обобщить, взяв в рассмотрение целый набор промежуточных
представлений $P_v$. Но сперва приведем один факт, связанный со свойствами
естественного соединения.

\begin{statement}
Пусть $\Re_1 = R_1 \bowtie \dots \bowtie R_k$ - результат естественного
соединения некоторых $k$ отношений. Пусть также $\Re_2 = R_1 \bowtie \dots
\bowtie R_k \bowtie R_{k+1} \bowtie \dots \bowtie R_{n}$. 
Тогда $\Re_2 [\langle \bowtie_{i=1}^{k} R_i \rangle] \subseteq \Re_1$
\label{join_property}
\end{statement}

Это действительно так, ведь после проведения операции естественного соединения
с дополнительными отношениями исходные кортежи, содержавшиеся в $\Re_1$, могут
лишь ''отсеяться'' операцией естественного соединения. Тогда, взяв вырезку по
исходным атрибутам, получим как максимум то же самое отношение $\Re_1$.

\input{theorem_1_mult}

\input{theorem_2_mult}

\section{Удаление лишних кортежей из промежуточных представлений}

Результаты, полученные в теоремах \ref{th_base}, \ref{th_mult} нельзя сразу
использовать на практике. Отношение $P^{\ast}$ содержится в имеющемся
представлении, однако неизвестно, какие именно кортежи являются частью
$P^{\ast}$. Лишние кортежи могут возникнуть по двум причинам:
\begin{enumerate}
  \item В силу Утверждения \ref{proj_property_of_inclusion}, так как правая
  часть содержит проекцию исходной формулы $F^{\ast}$ на некоторое множество
  атрибутов.
  \item В силу Утверждения \ref{join_property}, так как в промежуточном
  представлении отношений не больше, чем в искомом $P^{\ast}$.
\end{enumerate}
Поэтому необходимо сперва удалить лишние кортежи (если они есть) из
промежуточных представлений.

\input{alg_filter_tj}

\input{bibliography}
\end{document}