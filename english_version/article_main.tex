\documentclass[10pt,a4paper]{article}
\author{Mosin Sergey, Zykin Sergey}
\usepackage{amssymb,amsmath}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{xcolor}
\floatname{algorithm}{Algorithm}
\newtheorem{theorem}{Theorem}
\newtheorem{mydef}{Definition}
\newtheorem{statement}{Statement}
\newtheorem*{consequence}{Consequence}
\newtheorem{note}{Note}
\def \eval #1#2{\left.#1\right\vert_{#2}}
\def \<#1> {\langle #1 \rangle}
\def \n #1{\mathit{#1}}
\title{Creating table-like applications using cached data}
\author{
Mosin Sergey, Zykin Sergey \footnote{The paper is supported by RFFI grant
#12-07-00066-a}
\date{}
}
\begin{document}
\maketitle
\section{Abstract}

\section{Introduction}
A lot of nowadays Big Data analysis solutions use Online Analytical Processing
technologies, formed in early 90s already \cite{codd}. A lot of fundamental
\cite{lecht,lehner,mazon} and applied \cite{vassi, peder, progressive, giorg}
results were obtained in this field lately.

The purpose of this paper is the research of the problem of creating Dynamic
Multidimensional Data Representation from the Relational Database with a help of
cached data representations on a user computer, supplied with Graphical
Processing Unit (GPU). We don't require any transformation of the initial
Database schema, even to the hierarchical model.

This problem is connected with a field of query optimization, because it aims
the decrease in data transfer from a Database server. Cached data is actively
used in Database Management Systems (DBMS). But mostly it is only repeating use
of data, written in cache, without any prior data analysis to define any partial
or combined use. The DBMS can only avoid requesting blocks of data from external
devices while serving the query, if they are present(?ed) in cache. It means
block number analysis, not their information.

This paper is based on the results, obtained in \cite{zyk_pol}. We removed
condition that restricted(?) Intermediate Representation (IR) attributes and
also made some generalizations on multiple IRs case.

\section{Existing solutions overview and comparison}

In a field of fundamental researches huge amount of publications aim optimal
query plan generation based on a formal set of rules, that don't use SQL operator
predicate domains (logical optimization). In other cases those domains are
taken into account for statistical evaluations to improve physical access to the
data. Stream data query executing problems, described in
\cite{Olston03, Denny05}, are related to our problem closer, but different aims
lead us to different results. The most similar to our work is paper
\cite{Afrati06}. They analyze conjunctive queries on data domains with
predicates in a form of arithmetical comparisons and present query computation
algorithms using IRs. In this paper the special case of universal relational
query is considered. It is a query on the Database relations, not particular
domains. Although we had similar aims, the results obtained differ because of
stated factors. In particular, in our work there is no need to create any
algorithms of data selection, as they are replaced by Relational Algebra.

There are some works, which examine query optimization problem in the case of
multidimensional warehouse representation with a use of dynamically formed
representations. Two basic methods are used there: statical \cite{baralis,
gupta, gupta-mumick} and dynamical one \cite{scheuermann, shim, kalnis, chang}.
The first one is based on a fixed amount of queries. In the latter one queries
for reservation are chosen based on appearance statistic and computational cost
of query execution. As a data source Data Warehouses or Relational Databases in
the hierarchical form are used. Special queries for data manipulation are
considered. In this paper we use split dimension generation for the data
required for current analysis. Hence, we are interested in standard SQL queries
to the Database and IRs. The resulting representation can then be processed by
special multidimensional data queries.

In the \cite{Keller96} paper they claim for cache content analysis, and
predicates correspond to IRs in our approach. Cached data usage problem is solved
in terms of predicate deduction. In our paper we solve this problem by means of
computation of cached query results domains that correspond to the IRs. It allows
us to define IR records that can be used to form new representation and new SQL
queries that will let us load missing data from Database server. The following
example demonstrates suggested approach.


{\bf Example 1.} The task is to receive data representation as in the table
\ref{def_T_1}. Dimension attributes are in bold, measure attributes are italic,
else are attribute values.

\begin{table}[h!]
\caption{\label{def_T_1} Curriculum.}
\begin{center}
\begin{tabular}{|c|c||c|c|c|c|}
\cline{2-6}
\multicolumn{1}{c|}{} & \multicolumn{1}{|r||}{\bf Semester} & \multicolumn{2}{|c|}{2} & \multicolumn{2}{|c|}{3}  \\
\cline{2-6}
\multicolumn{1}{c|}{} & {\bf Discipline} & Physics & Chemistry & Physics & Chemistry \\
\hline \cline{2-6}
{\bf Department} & {\bf Class} & {\it Hours} & {\it Hours} & {\it Hours} & {\it Hours} \\
\hline
 & C-321 & & 36 & 18 & 9 \\
\cline{2-6}
D. of Chemistry & Х-322 & & 48 & 18 & 9 \\
\cline{2-6}
 & C-331 & & 24 & 18 & 9 \\
\hline
 & P-321 & 48 & & 24 & \\
\cline{2-6}
D. of Physics & P-322 & 48 & & 24 & \\
\cline{2-6}
 & P-331 & 64 & & 24 & \\
\hline
\end{tabular}
\end{center}
\end{table}
Assume the following precomputed relations on the user PC:  $P_1$,
$P_2$, $P_3$. Table schemes are the following then: $P_1$=(Department number, Department), without any data constraints; $P_2$=(Discipline number, Discipline), without data constraints; $P_3$=(Department number, Discipline number, Semester, Class, Hours), with the following constraint:
$F_3 =(\mbox{Semester} \leq 2) \wedge (\mbox{Department} = \mbox{D. of Chemistry})$.
Assume the user has made the following logical constraint on the data to be represented in the table: $F^{\ast} = (\mbox{Semester} \leq 3)$. Comparing these formulas domains, it's easy to see that $P_1$ and $P_2$ have enough data to form table \ref{def_T_1}, whereas $P_3$ needs to be expanded with data. After defining $F^{\ast}$ and $F_3$ domains we can form a new formula: $F=((\mbox{Semester} = 3) \wedge (\mbox{Deparmtent=D. of Chemistry}))
\vee ((\mbox{Semester} \leq 3) \wedge (\mbox{Deparmtent} \neq \mbox{D. of Chemistry}))$. Using $P_3$ schema and $F$ formula, we can now make an SQL command to be executed on server. As a result, we transfer less data over the network.

\section{Определение и свойства логических ограничений}

Для упрощения вычисления областей истинности будем рассматривать логические формулы в дизъюнктивной
нормальной форме. В общем случае формула $F$ имеет вид 

\begin{equation}
F = K_1 \vee K_2 \vee \dots \vee K_m ,
\label{def_F_1}
\end{equation}
\begin{equation}
K_i = T_1 \& T_2 \dots \& T_n, i = 1, \dots, m ,
\label{def_F_2}
\end{equation}
где $T_j, j = 1, \dots, n$ - предикаты, в которых явным образом
специфицированы расширенные имена атрибутов $R_i.A_j$ (атрибут $A_j$ в отношении
$R_i$):
\begin{itemize}
  \item	операция сравнения $ \n{Expr}_1 \theta \n{Expr}_2$, $\theta$ – операция
  сравнения $(\theta \in \{=, \neq, >, <, \leq, \geq\})$, $\n{Expr}_i$ –
  согласованные по типам допустимые выражения, определенные на множестве
  расширенных имен атрибутов и констант;
  \item операция $\n{Expr}_1 \n{[NOT]} \n{BETWEEN} \n{Expr}_2 \n{AND}
  \n{Expr}_3$ (содержимое в прямоугольных скобках $[*]$ для предиката не
  является обязательным при написании);
  \item операция $\n{Expr} \n{[NOT]} \n{IN} S$, где $S$ – список значений либо
  подзапрос, результатом которого является столбец атрибута $A_j$ в отношении
  $R_i$;
  \item операция $\n{Str}_1 \n{[NOT]} \n{LIKE} \n{Str}_2$, где $\n{Str}_i$ –
  строки;
  \item операция $\n{Expr} \theta \n{ALL/ANY} S$.
\end{itemize}

\begin{note}
Здесь и далее будем полагать, что в формулах отсутствуют тривиальные условия на
атрибуты, например, условия вида $Expr_1 = Expr_1$ и сводящихся к ним.
В общем случае будем полагать, что множество возможных значений атрибута $A_l$
в отношении $R_i$ не включается целиком в область истинности предиката $T_j (\dots , R_i . A_l ,\dots )$. Такие
условия могут быть удалены из формулы, не меняя области истинности (будет
определено далее).
\label{trivial}
\end{note}

\begin{mydef}
Множество атрибутов, входящих в формулу, выражает размерность формулы и
обозначается $\<F> $.

\begin{equation}
\<F> = \{R_1^F.A_1^F, \dots, R_k^F.A_k^F\}
\label{def_F_3}
\end{equation}
\end{mydef}



Перечисленные варианты операций используют не все возможности языка SQL.
Например, предикат $\n{EXISTS}$ не используется, поскольку в нем явно не
специфицированы расширенные имена атрибутов, предикат $\n{NULL}$ используется
в данной работе для другой цели.

При вычислении логического выражения может быть получено значение $\n{UNKNOWN}$,
если на текущем кортеже $t$ атрибут принимает значение $\n{NULL}$, поскольку
результаты вычисления логических выражений в SQL-запросах соответствуют
трехзначной логике. Это приводит к неоднозначной интерпретации результата не только
обычными пользователями, но и опытными программистами. Для решения этой проблемы
предлагается ограничение: каждому атрибуту, входящему в $F^{\ast}$, явно присваивается признак
<<Использование неопределенного значения>> с двумя взаимоисключающими значениями <<Да>> или <<Нет>>.
Семантика этого признака такова, что если ему присвоено значение <<Да>>, то появление значения $\n{NULL}$
для указанного атрибута в текущем кортеже $t$ не служит основанием удаления этого кортежа из
дальнейшего рассмотрения. В противном случае значение признака <<Нет>> гарантирует, что появление
значения $\n{NULL}$ для указанного атрибута в текущем кортеже $t$ приведет к удалению этого кортежа из
дальнейшего рассмотрения.

Запишем формулу (\ref{def_F_1}) для $F$ в следующем виде: $ F ( \dots, T_j , \dots )$, где $T_j$ - предикаты
формулы (\ref{def_F_2}). Тогда после предложенного преобразования она примет следующий вид:
$F( \dots, T'_j , \dots )\wedge_{i,j}(R_i .A_j \neq  \n{NULL})$, где  $\wedge_{i,j}(R_i .A_j \neq  \n{NULL})$ - конъюнкция
по всем атрибутам формулы $F$, для которых не допустимо значение $\n{NULL}$.
Операция $T'_j = (T_j \vee_{i,j}(R_i .A_j = \n{NULL}))$, где  $\vee_{i,j}(R_i .A_j = \n{NULL})$ - дизъюнкция
по всем атрибутам предиката $T_j$, для которых допустимо значение $\n{NULL}$. Внешние скобки для предиката
$T'_j$ определяют приоритет выполнения операций. Несложно убедиться, что в рамках трехзначной логики
преобразованная формула принимает только значения $\n{TRUE}$ и $\n{FALSE}$. Кроме того, несложно убедиться,
что в рамках двузначной логики, когда в кортежах отсутствуют неопределенные значения, исходная формула $F$
будет эквивалентна преобразованной формуле, поэтому семантика представления $P$ практически не искажается.
Для раскрытия термина "практически" рассмотрим наиболее неудобный пример: пусть $F = R_1 .A_2 > 3 \vee R_3 .A_4 < 4$
и на кортеже $t$ атрибут $R_1 .A_2$ принимает допустимое значение $\n{NULL}$, а предикат $R_3 .A_4 < 4$ принимает
значение $\n{FALSE}$. Тогда преобразование формулы $F$ на кортеже $t$ будет иметь значение $\n{TRUE}$,
что не совсем очевидно. Далее будем предполагать, что все формулы $F$ являются преобразованными.

Введем в рассмотрение множество $\mathcal{A} =$ $\{(a_1, \dots, a_n)
\mid a_i \in Dom(A_i), i=1,\dots,n\}$, где $Dom(A_i)$ - множество всех допустимых значений атрибута $A_i$.
Декартово прозведение $Dom(A_1)\times Dom(A_2)\times \dots \times Dom(A_n)$ - $n$-мерное пространство
значений всех атрибутов базы данных. Текущее состояние базы данных соответствует точке в этом пространстве.
Допустимые состояния образуют некоторую область в этом пространстве, соответствующую ограничениям целостности на данные.
В замечании \ref{trivial} речь идет о всем пространстве состояний, а не только допустимых состояниях.

\begin{mydef}
Областью истинности логической формулы $F$, заданной (\ref{def_F_1}),
(\ref{def_F_2}), (\ref{def_F_3}), является множество, определяемое по следующему
правилу: $M (F) = \{a \in \mathcal{A} \mid F(a) = \n {TRUE}\}$.
\end{mydef}

\begin{note}
Размерность формулы $F$ может быть меньше
размерности $\mathcal{A}$, при этом атрибуты, не входящие в формулу, могут
принимать любые значения.
\end{note}

\begin{note}
Сложность компонентов предикатов $\n{Expr}$, $S$ и $\n{Str}$ определяется
возможностями программного обеспечения по вычислению областей истинности
$F$, как это показано в примере 1.
\end{note}

В соответствии с данными определениями легко понять, как будут устроены операции
над областями истинности, соответствующими формулам. $M (F)$ для некоторой формулы
$F$, заданной своей ДНФ, является объединением областей истинности, представленных
отдельными конъюнктами формулы. Область истинности каждого конъюнкта определяется
определяется как пересечение областей истинности предикатов, входящих в него.

Далее введем определения, касающиеся модификации вхождения атрибутов в
логические формулы.

\begin{mydef}
Проекцей логической формулы $F$, заданной (\ref{def_F_1}), (\ref{def_F_2}),
(\ref{def_F_3}), на множество атрибутов $X$ называется логическая
формула $F[X], \<F[X]> $
$= X$, в которой все термы, содержащие
атрибуты $R_i^F.A_i^F \notin X$, заменены на тривиальный терм $\n{TRUE}$.
\label{projection}
\end{mydef}

\begin{statement}[Свойство включения]
$\forall X \subseteq \<F> \quad M(F) \subseteq M(F[X])$
\label{proj_property_of_inclusion}
\end{statement}
\begin{proof}
Если $X = \<F> $, то $F = F[X]$ и $M(F) = M(F[X])$. Пусть $X \subset \<F> $. Рассмотрим
произвольную точку $a \in M(F)$, то есть $F(a)=\n{TRUE}$. Преобразование формулы $F$
к виду $F[X]$ выполняется заменой предикатов $T_j$ значением $\n{TRUE}$, если они содержат
атрибут $A_j \in \<F> $ и $A_j \notin X$. Учитывая соотношения  (\ref{def_F_1}) и (\ref{def_F_2}),
получим $F([X])=\n{TRUE}$. Следовательно, $a \in M(F[X])$, что и требовалось показать.
\end{proof}

Данное свойство логических ограничений, заданных на состояниях базы
данных, в дальнейшем используется при формировании нового представления данных
из существующих сохраненных представлений.

\section{Исследование свойств промежуточных представлений данных}

Сохраненные промежуточные представления данных обозначим $P$=$\{ P_1$, $P_2$, $\dots$, $P_m \}$,
где $P_v = \pi_{X_v}(\sigma_{F_v} (R^v_1 \Join R^v_2 \Join \dots \Join R^v_{s(v)} ))$,
$s(v)$ – количество отношений в базе данных, использованных при формировании представления $P_v$,
$\pi_{X_v}$ - операция проекции по множеству атрибутов $X_v$, $\sigma_{F_v}$ - операция селекции
с логическим ограничением на кортежи $F_v$.
Целевое выражение, которое надо будет получить из представлений $P$, запишем в виде:
$$P^{\ast} = \pi_{X^{\ast}}(\sigma_{F^{\ast}} (R^{\ast}_1 \Join R^{\ast}_2\Join \dots \Join R^{\ast}_l )$$

Рассмотрим проблему формирования представления данных $P^{\ast}$ из существующих промежуточных
представлений $P_v$.

\input{theorem_1}

Предложенные в теореме условия гарантируют, что данные, необходимые для формирования
представления $P^{\ast}$, содержатся в промежуточном представлении $P_v$. Однако в нем
могут быть лишние кортежи, которые дают значение $\n{TRUE}$ при подстановке в формулу
$F^{\ast}$. Дело в том, что эти кортежи будут удалены при выполнении операции естественного
соединения с отношениями, которых не хватает в множестве $R^v_1 \Join R^v_2 \Join \dots \Join R^v_{s(v)} $
для совпадения с множеством $R^{\ast}_1 \Join R^{\ast}_2\Join \dots \Join R^{\ast}_l $.
Используя области области истинности логических выражений у СУБД можно запросить
минимально необходимый набор данных для определения лишних кортежей.

Следующая теорема соответствует частному случаю, однако проблема лишних кортежей не возникает.

\input{theorem_2}

Для формирования результирующего представления возможно использование
не одного, а нескольких промежуточных представлений $P_v$. Для этого
рассмотрим достаточно очевидное свойство операции естественного соединения.

\begin{statement}
Пусть $\Re_1 = R_1 \Join \dots \Join R_k$ - результат естественного
соединения некоторых $k$ отношений. Пусть также $\Re_2 = R_1 \Join \dots
\Join R_k \Join R_{k+1} \Join \dots \Join R_{n}$. 
Тогда $\Re_2 [\langle \Join_{i=1}^{k} R_i \rangle] \subseteq \Re_1$
\label{join_property}
\end{statement}

Это действительно так, поскольку после проведения операции естественного соединения
с дополнительными отношениями исходные кортежи, содержавшиеся в $\Re_1$, могут
лишь ''отсеяться'' операцией естественного соединения. Тогда, взяв вырезку по
исходным атрибутам, получим как максимум то же самое отношение $\Re_1$. Поскольку
операция естественного соединения коммутативна, то порядок присоединения отношений
не имеет значения.

\input{theorem_1_mult}

Как и в предыдущем случае существуют условия, при которых целевое представление
данных можно вычислить точно.

\input{theorem_2_mult}

Выполнение условий рассмотренных теорем не представляет собой  исключительный случай,
поскольку набор размерностей при формировании гиперкубов изменяется редко, что позволит
формировать эти размерности из промежуточных представлений без обращения к СУБД.

\section{Заключение}

Основной результат данной работы состоит в обосновании условий использования
зарезервированных представлений данных для формирования новых гиперкубов.
Эти представления данных могут храниться на компьютере пользователя-аналитика
и существенно сократить время на формирование данных, необходимых для принятия решений.

Традиционная проблема в системах, работающих не под управлением СУБД, заключается
в актуализации данных, полученных из БД. В технологии MOLAP она решается путем периодической
актуализации содержимого гиперкуба службой сопровождения. Аналогичный способ может быть
применен для актуализации представлений $P_v$. Для сокращения времени актуализации возможно
получить доступ к журналу изменений, который сопровождает СУБД, и актуализировать только те
представления, для которых изменились исходные данные в БД. Однако еще раз отметим, что данные,
используемые в размерностях гиперкуба, обычно редко модифицируются в БД.

Предлагаемый подход подразумевает в дальнейшем применение графических процессоров
для выполнения промежуточных операций фильтрации и соединения различных представлений данных.
Исследования в этой области показали, что операции на графическом процессоре выполняются
существенно быстрее, чем на центральном процессоре, для небольших объемов данных. При увеличении
объемов производительность падает. Причина очевидна: пока данные помещаются в быструю память
графического процессора, операции с ними выполняются быстро. При увеличении объемов данных появляется
необходимость их многократного перемещения между различными видами памяти, что снижает
производительность. С одной стороны, производители графических процессоров постоянно наращивают
быструю память, с другой – повторное использование данных наиболее актуально для размерностей
многомерных таблиц, для которых требуется сравнительно небольшой объем памяти, что в совокупности
делает целесообразным применение графических процессоров при решении указанной проблемы.


\input{bibliography}
\end{document}